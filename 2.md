Soru 1: Graflarda DFS (Derinlik Öncelikli Arama)
Soru: Komşuluk Listesi (Adjacency List) ile tutulan bir grafta, verilen bir düğümden başlayarak tüm grafı DFS (Depth First Search) ile gezen ve gidilen düğümleri ekrana yazan recursive (özyinelemeli) fonksiyonu yazınız. visited dizisinin dışarıdan gönderildiğini varsayın.



// u: Şu anki düğüm, adj: Komşuluk listesi, visited: Ziyaret edildi mi?
void DFS(int u, vector<vector<int>>& adj, vector<bool>& visited) {
    // 1. Önce geldiğimiz düğümü işaretle ve yaz
    visited[u] = true;
    cout << u << " ";

    // 2. Komşularını gez
    for (int v : adj[u]) {
        // Eğer komşu daha önce ziyaret edilmediyse, ona git (Recursion)
        if (!visited[v]) {
            DFS(v, adj, visited);
        }
    }
}




Hash Table - Quadratic ProbingSoru: Hash tablosunda çakışma (collision) olduğunda Quadratic Probing ($index + i^2$) yöntemini kullanan ekleme (insert) mantığındaki while döngüsünü tamamlayınız.


// table: Tablo dizisi, size: Tablo boyutu, key: Eklenecek değer
// Hash fonksiyonu: key % size olsun.
int i = 0;
int index = key % size;
int h = index; // İlk hash değerini sakla

// Hücre doluysa (table[h] != -1) yeni yer ara
while (table[h] != -1) {
    i++;
    // Formül: (İlkIndex + i*i) % Boyut
    h = (index + i * i) % size;
    
    // Güvenlik önlemi: Sonsuz döngüye girmemesi için i çok büyürse durdurulabilir
    if (i > size) break; 
}
// Boş yeri bulduk
table[h] = key;



Selection Sort (Seçmeli Sıralama)
Soru: Selection Sort algoritmasında, her adımda dizinin geri kalanındaki en küçük elemanın indisini bulan iç döngüyü yazınız.



// i: Dış döngünün o anki indisi (sıralı kısmın sonu)
int minIndex = i; // Şimdilik en küçük bu diyelim

for (int j = i + 1; j < n; j++) {
    // Eğer daha küçüğünü bulursak, indisini kap
    if (arr[j] < arr[minIndex]) {
        minIndex = j;
    }
}
// Döngü bitince minIndex en küçük elemanı gösterir, sonra swap yapılır.





Bölüm 2: "Trace" (Adım Adım İşletme) Soruları
Hocalar sınavda "Bu dizi bu algoritmadan geçerse sonuç ne olur?" diye sormayı çok sever.

Soru 4: Min-Heap'ten Eleman Silme
Verilen Min-Heap Dizisi: [2, 5, 12, 7, 6, 20, 15] (Dizi gösterimi: Kök=2, SolÇocuk=5, SağÇocuk=12...)

Soru: Bu Min-Heap'ten "deleteMin" (en küçüğü sil) işlemi yapıldığında dizinin son hali ne olur? Adımları yazınız.

Cevap Anahtarı:

Kökü Sil: En tepedeki 2 gider.

Son Elemanı Başa Al: Dizinin en sonundaki 15 köke geçer. Dizi: [15, 5, 12, 7, 6, 20] (Son eleman eksildi).

Aşağı İndir (Percolate Down): Kök 15, çocukları 5 ve 12.

En küçük çocuk 5. 15 > 5 olduğu için 15 ile 5 yer değiştirir.

Yeni durum: [5, 15, 12, 7, 6, 20]

Tekrar Kontrol: 15'in yeni çocukları 7 ve 6.

En küçük çocuk 6. 15 > 6 olduğu için yer değiştirir.

Yeni durum: [5, 6, 12, 7, 15, 20]

Sonuç: [5, 6, 12, 7, 15, 20]

Soru 5: Quick Sort (Partition Mantığı)
Dizi: [50, 20, 70, 10, 60, 30] Pivot: İlk eleman (50) seçiliyor.

Soru: Quick Sort'un ilk "Partition" (Bölümleme) işlemi bittiğinde dizi nasıl görünür? (Pivotun solunda ondan küçükler, sağında büyükler olmalı).

Cevap Anahtarı:

Amaç 50'yi doğru yerine koymak.

Küçükler sola: 20, 10, 30

Büyükler sağa: 70, 60

Pivot ortada: 50

Olası Sonuç (Algoritma varyasyonuna göre değişir ama pivotun yeri kesindir): [30, 20, 10, 50, 60, 70]

Not: Sınavda pivotun tam indeksini sorabilirler. Burada pivot 3. indekse (0'dan başlayınca) yerleşir.


<img width="741" height="763" alt="image" src="https://github.com/user-attachments/assets/7d8ca343-2f5a-48ce-bee1-2cedeaf777aa" />


