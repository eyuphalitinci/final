Aşağıdaki C++ kod parçasının zaman karmaşıklığını (Big-O) hesaplayınız ve nedenini açıklayınız.
void islemYap(int n, vector<int>& arr) {
    // Bölüm A
    for (int i = 0; i < n; i++) {
        cout << arr[i] << endl;
    }
    
    // Bölüm B
    for (int i = 1; i < n; i = i * 2) {
        // Heap'e ekleme benzeri bir işlem yapılıyor
        int k = n;
        while (k > 0) {
            k = k / 2;
            cout << "*";
        }
    }
}

<img width="441" height="233" alt="image" src="https://github.com/user-attachments/assets/c2b0a196-f2d7-4334-b74f-53953b20fc79" />

Hash Table Trace (20p)
Boyutu M = 10 olan bir Hash Tablosu ve Hash fonksiyonu h(x) = x % 10 verilmiştir.
Verilen anahtarlar: {12, 22, 42, 5, 15} Bu anahtarları Linear Probing (Doğrusal Araştırma) yöntemi ile tabloya yerleştiriniz. Çakışma (Collision) durumlarını gösteriniz.

<img width="409" height="179" alt="image" src="https://github.com/user-attachments/assets/553d10d2-b632-471c-92cc-f45c6e9946a6" />


Kod Yazma - Graf (20p)
Vizedeki "Yaprak Sayısı" sorusuna benzer bir mantıkla; Bir Yönlü Grafta (Directed Graph) verilen bir u düğümünün "Giden Kenar Sayısını" (Out-Degree) hesaplayan fonksiyonu, 
grafın Komşuluk Listesi (Adjacency List) ile tutulduğunu varsayarak yazınız.
// Komşuluk listesi yapısında, adj[u] vektörünün boyutu
int outDegreeHesapla(const vector<vector<int>>& adj, int u) {
    // Kontrol: Geçersiz düğüm isteği
    if (u < 0 || u >= adj.size()) {
        return 0; 
    }
    
    // Komşuluk listesi yapısında, adj[u] vektörünün boyutu
    // zaten o düğümden çıkan kenar sayısını verir.
    // Ekstra bir döngüye gerek yoktur, doğrudan size() döndürülür.
    return adj[u].size();
}
